<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà‡πÅ‡∏´‡∏•‡πà‡∏á‡∏ô‡πâ‡∏≥</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
     integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
     crossorigin=""/>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
     integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
     crossorigin=""></script>
    <!-- ‡πÄ‡∏û‡∏¥‡πà‡∏° proj4 library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.9.0/proj4.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
        }
        #map { 
            height: 100vh; 
            width: 100%;
        }
        
        /* ‡∏õ‡∏£‡∏±‡∏ö‡πÅ‡∏ï‡πà‡∏á Layer Control */
        .leaflet-control-layers {
            font-size: 14px;
            border-radius: 12px;
            transition: all 0.3s ease;
        }
        
        /* ‡∏õ‡∏∏‡πà‡∏°‡∏™‡∏•‡∏±‡∏ö (collapsed state) - ‡πÅ‡∏™‡∏î‡∏á‡πÄ‡∏õ‡πá‡∏ô emoji grayscale */
        .leaflet-control-layers-toggle {
            background-image: none !important;
            width: 50px !important;
            height: 50px !important;
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 28px;
            filter: grayscale(100%);
            transition: filter 0.3s ease;
        }
        
        .leaflet-control-layers-toggle::before {
            content: 'üó∫Ô∏è';
        }
        
        /* ‡πÄ‡∏°‡∏∑‡πà‡∏≠ hover ‡πÉ‡∏´‡πâ‡∏Å‡∏•‡∏±‡∏ö‡∏°‡∏≤‡πÄ‡∏õ‡πá‡∏ô‡∏™‡∏µ‡∏õ‡∏Å‡∏ï‡∏¥ */
        .leaflet-control-layers-toggle:hover {
            filter: grayscale(0%);
        }
        
        /* ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏Ç‡∏¢‡∏≤‡∏¢ (expanded state) */
        .leaflet-control-layers-expanded .leaflet-control-layers-toggle {
            display: none;
        }
        
        .leaflet-control-layers-expanded {
            padding: 10px;
        }
    </style>
</head>
<body>
    <div id="map"></div>

    <script>
        // ‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà
        var map = L.map('map').setView([16.240027, 99.450809], 10);

        // ‡∏™‡∏£‡πâ‡∏≤‡∏á Base Maps ‡∏´‡∏•‡∏≤‡∏¢‡πÅ‡∏ö‡∏ö
        var osmStandard = L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
            maxZoom: 19,
            attribution: '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>'
        });

        var topoMap = L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', {
            maxZoom: 17,
            attribution: 'Map data: &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a>, <a href="http://viewfinderpanoramas.org">SRTM</a> | Map style: &copy; <a href="https://opentopomap.org">OpenTopoMap</a>'
        });

        var satellite = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
            maxZoom: 19,
            attribution: 'Tiles &copy; Esri &mdash; Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community'
        });

        // ‡πÄ‡∏û‡∏¥‡πà‡∏° Base Map ‡πÅ‡∏£‡∏Å‡πÄ‡∏õ‡πá‡∏ô‡∏Ñ‡πà‡∏≤‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô
        osmStandard.addTo(map);

        // ‡∏™‡∏£‡πâ‡∏≤‡∏á object ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Layer Control
        var baseMaps = {
            "‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà‡∏°‡∏≤‡∏ï‡∏£‡∏ê‡∏≤‡∏ô (Standard)": osmStandard,
            "‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà‡∏†‡∏π‡∏°‡∏¥‡∏õ‡∏£‡∏∞‡πÄ‡∏ó‡∏® (Topography)": topoMap,
            "‡∏†‡∏≤‡∏û‡∏î‡∏≤‡∏ß‡πÄ‡∏ó‡∏µ‡∏¢‡∏° (Satellite)": satellite
        };

        var overlayMaps = {
            // ‡∏à‡∏∞‡πÄ‡∏û‡∏¥‡πà‡∏° GeoJSON layer ‡πÄ‡∏Ç‡πâ‡∏≤‡∏°‡∏≤‡∏ó‡∏µ‡∏´‡∏•‡∏±‡∏á
        };

        // ‡πÄ‡∏û‡∏¥‡πà‡∏° Layer Control ‡∏•‡∏á‡πÉ‡∏ô‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà
        var layerControl = L.control.layers(baseMaps, overlayMaps, {
            position: 'topright',
            collapsed: true  // ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÄ‡∏õ‡πá‡∏ô true ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡∏ã‡πà‡∏≠‡∏ô‡∏ï‡∏≠‡∏ô‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô
        }).addTo(map);

        // ‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏£‡∏∞‡∏ö‡∏ö‡∏û‡∏¥‡∏Å‡∏±‡∏î
        var from = "+proj=utm +zone=47 +datum=WGS84 +units=m +no_defs";
        var to   = "+proj=longlat +datum=WGS84 +no_defs";

        // ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡πÅ‡∏õ‡∏•‡∏á UTM ‚Üí Lat/Lon
        function convertUTMtoLatLng(geojson) {
            geojson.features.forEach(f => {
                if (f.geometry.type === "Polygon") {
                    f.geometry.coordinates = f.geometry.coordinates.map(ring =>
                        ring.map(coord => {
                            // ‡πÅ‡∏õ‡∏•‡∏á‡∏û‡∏¥‡∏Å‡∏±‡∏î UTM ‡πÄ‡∏õ‡πá‡∏ô Lat/Lon
                            let ll = proj4(from, to, coord);
                            // Leaflet ‡πÉ‡∏ä‡πâ [lat, lon] ‡πÅ‡∏ï‡πà GeoJSON ‡πÉ‡∏ä‡πâ [lon, lat]
                            return [ll[0], ll[1]];
                        })
                    );
                } else if (f.geometry.type === "MultiPolygon") {
                    f.geometry.coordinates = f.geometry.coordinates.map(polygon =>
                        polygon.map(ring =>
                            ring.map(coord => {
                                let ll = proj4(from, to, coord);
                                return [ll[0], ll[1]];
                            })
                        )
                    );
                }
            });
            return geojson;
        }

        // ‡πÇ‡∏´‡∏•‡∏î‡πÑ‡∏ü‡∏•‡πå GeoJSON
        fetch("0Water_body.json")
            .then(res => {
                if (!res.ok) {
                    throw new Error(`‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÇ‡∏´‡∏•‡∏î‡πÑ‡∏ü‡∏•‡πå‡πÑ‡∏î‡πâ: ${res.status}`);
                }
                return res.json();
            })
            .then(data => {
                // ‡πÅ‡∏õ‡∏•‡∏á‡∏û‡∏¥‡∏Å‡∏±‡∏î
                let converted = convertUTMtoLatLng(data);
                
                // ‡πÄ‡∏û‡∏¥‡πà‡∏° GeoJSON layer ‡∏•‡∏á‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà
                let geoLayer = L.geoJSON(converted, {
                    style: { 
                        color: "blue", 
                        weight: 2,
                        fillColor: "lightblue",
                        fillOpacity: 0.5
                    },
                    onEachFeature: function(feature, layer) {
                        if (feature.properties) {
                            let popupContent = '<div><strong>‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ö‡πà‡∏≠‡∏ô‡πâ‡∏≥</strong><br>';
                            for (let key in feature.properties) {
                                popupContent += `${key}: ${feature.properties[key]}<br>`;
                            }
                            popupContent += '</div>';
                            layer.bindPopup(popupContent);
                        }
                    }
                }).addTo(map);
                
                // ‡πÄ‡∏û‡∏¥‡πà‡∏° GeoJSON layer ‡πÄ‡∏Ç‡πâ‡∏≤‡πÑ‡∏õ‡πÉ‡∏ô Layer Control
                layerControl.addOverlay(geoLayer, "‡∏ä‡∏±‡πâ‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ö‡πà‡∏≠‡∏ô‡πâ‡∏≥ (Water Bodies)");
                
                // ‡∏õ‡∏£‡∏±‡∏ö‡∏°‡∏∏‡∏°‡∏°‡∏≠‡∏á‡πÉ‡∏´‡πâ‡∏û‡∏≠‡∏î‡∏µ‡∏Å‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•
                map.fitBounds(geoLayer.getBounds());
            })
            .catch(error => {
                console.error('Error:', error);
                alert('‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÇ‡∏´‡∏•‡∏î‡πÑ‡∏ü‡∏•‡πå: ' + error.message);
            });
    </script>
</body>
</html>